/**
 * Service de configuration unifi√© pour HatCast
 * G√®re la d√©tection d'environnement et la configuration des ressources Firebase
 * avec logique de priorit√© intelligente et tra√ßabilit√© compl√®te
 */

import logger from './logger.js'

class ConfigService {
  constructor() {
    this.environment = this.detectEnvironment();
    this.config = null;
    this.configSources = {}; // Tra√ßabilit√© de la source de chaque valeur
    this.isInitialized = false;
  }

  /**
   * D√©tecte l'environnement actuel bas√© sur l'URL
   */
  detectEnvironment() {
    const hostname = window.location.hostname;
    
    if (hostname.includes('staging') || hostname.includes('hatcast-staging')) {
      return 'staging';
    } else if (hostname.includes('localhost') || hostname.includes('192.168.1.134') || hostname.includes('127.0.0.1')) {
      return 'development';
    } else {
      return 'production';
    }
  }

  /**
   * Initialise la configuration avec logique de priorit√© intelligente
   */
  async initializeConfig() {
    if (this.isInitialized) {
      return this.config;
    }

    logger.info('üîß Initialisation de la configuration avec logique de priorit√© intelligente...');
    
    // 1. Configuration de base par environnement
    const baseConfig = this.getBaseConfig();
    
    // 2. Configuration Firebase avec priorit√© intelligente
    const firebaseConfig = await this.loadFirebaseConfig();
    
    // 3. Configuration des sessions avec priorit√© intelligente
    const sessionConfig = await this.loadSessionConfig();
    
    // 4. Fusion des configurations (sans les secrets pour l'instant)
    this.config = {
      ...baseConfig,
      firebase: firebaseConfig,
      sessions: sessionConfig,
      secrets: {} // Initialement vide, sera charg√© plus tard
    };
    
    this.isInitialized = true;
    
    // 5. Log de la tra√ßabilit√©
    this.logConfigSources();
    
    return this.config;
  }

  /**
   * Charge les secrets Firebase de mani√®re diff√©r√©e (apr√®s initialisation Firebase)
   */
  async loadSecretsDelayed() {
    if (this.configSources.secrets) {
      return this.config.secrets; // D√©j√† charg√©
    }

    logger.info('üîê Chargement diff√©r√© des secrets Firebase...');
    
    try {
      const secrets = await this.loadSecretsConfig();
      this.config.secrets = secrets;
      return secrets;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Erreur lors du chargement diff√©r√© des secrets:', error);
      return {};
    }
  }

  /**
   * Retourne la configuration pour l'environnement actuel
   */
  async getConfig() {
    if (!this.isInitialized) {
      await this.initializeConfig();
    }
    return this.config;
  }

  /**
   * Retourne la configuration de mani√®re synchrone (pour compatibilit√©)
   * ATTENTION: Peut retourner null si pas encore initialis√©e
   */
  getConfigSync() {
    return this.config;
  }

  /**
   * Configuration de base par environnement (sans valeurs sensibles)
   */
  getBaseConfig() {
    const env = this.environment;
    
    const baseConfigs = {
      development: {
        firestore: {
          database: 'development',
          region: 'europe-west3'
        },
        storage: {
          prefix: 'development/'
        },
        email: {
          service: 'ethereal',
          capture: true,
          from: {
            name: 'HatCast Dev',
            email: 'dev@ethereal.email',
            displayName: 'HatCast Dev <dev@ethereal.email>'
          },
          replyTo: 'dev@ethereal.email'
        },
        magicLinks: {
          expirationDays: 7
        },
        notifications: {
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        },
        hosting: {
          url: 'https://192.168.1.134:5173'
        },
        pwa: {
          serviceWorkerEnabled: true,
          installPromptEnabled: true
        },
        push: {
          enabled: true,
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        }
      },
      staging: {
        firestore: {
          database: 'staging',
          region: 'us-central1'
        },
        storage: {
          prefix: 'staging/'
        },
        email: {
          service: 'ethereal',
          capture: true,
          from: {
            name: 'HatCast Dev',
            email: 'dev@ethereal.email',
            displayName: 'HatCast Dev <dev@ethereal.email>'
          },
          replyTo: 'dev@ethereal.email'
        },
        magicLinks: {
          expirationDays: 7
        },
        notifications: {
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        },
        hosting: {
          url: 'https://hatcast-staging.web.app'
        },
        pwa: {
          serviceWorkerEnabled: true,
          installPromptEnabled: true
        },
        push: {
          enabled: true,
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        }
      },
      production: {
        firestore: {
          database: 'default',
          region: 'us-central1'
        },
        storage: {
          prefix: 'production/'
        },
        email: {
          service: 'gmail',
          capture: false,
          from: {
            name: 'HatCast',
            email: 'impropick@gmail.com',
            displayName: 'HatCast <impropick@gmail.com>'
          },
          replyTo: 'impropick@gmail.com'
        },
        magicLinks: {
          expirationDays: 7
        },
        notifications: {
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        },
        hosting: {
          url: 'https://selections.la-malice.fr'
        },
        pwa: {
          serviceWorkerEnabled: true,
          installPromptEnabled: true
        },
        push: {
          enabled: true,
          vapidKey: 'BG1NEd8-vnwABAfwt9D7pqO2PfHn_UpX8EqMHPX_TuIjk87KRxuQ66Kojfbe-4f_zBpyJZIH4biEVqt4YGjyAU0'
        }
      }
    };

    return baseConfigs[env] || baseConfigs.production;
  }

  /**
   * Charge la configuration Firebase avec logique de priorit√© intelligente
   */
  async loadFirebaseConfig() {
    const env = this.environment;
    logger.info(`üîç Chargement de la configuration Firebase pour l'environnement: ${env}`);

    // Valeurs par d√©faut (fallback)
    const defaultConfig = {
      apiKey: 'AIzaSyDCqJRmxKiIzuAhgXsmXICCx_O65aujNa0',
      authDomain: 'impro-selector.firebaseapp.com',
      projectId: 'impro-selector',
      storageBucket: 'impro-selector.firebasestorage.app',
      messagingSenderId: '730278491306',
      appId: '1:730278491306:web:c966af1179221e91118cd3',
      measurementId: 'G-3NB062D088'
    };

    const finalConfig = {};
    const sources = {};

    // Priorit√© 1: Variables d'environnement VITE (pour le dev local)
    if (env === 'development') {
      logger.info('üîç Priorit√© 1: Recherche dans les variables VITE...');
      
      const viteConfig = this.loadFromViteEnv();
      Object.keys(defaultConfig).forEach(key => {
        if (viteConfig[key]) {
          finalConfig[key] = viteConfig[key];
          sources[key] = 'VITE_ENV';
        } else {
          finalConfig[key] = defaultConfig[key];
          sources[key] = 'DEFAULT_FALLBACK';
        }
      });
    } else {
      // Priorit√© 2: Tentative de r√©cup√©ration depuis Firebase Functions
      logger.info('üîç Priorit√© 2: Tentative de r√©cup√©ration depuis Firebase Functions...');
      
      try {
        const firebaseConfig = await this.loadFromFirebaseFunctions();
        if (firebaseConfig) {
          logger.info('‚úÖ Configuration r√©cup√©r√©e depuis Firebase Functions');
          Object.keys(defaultConfig).forEach(key => {
            if (firebaseConfig[key]) {
              finalConfig[key] = firebaseConfig[key];
              sources[key] = 'FIREBASE_FUNCTIONS';
            } else {
              finalConfig[key] = defaultConfig[key];
              sources[key] = 'DEFAULT_FALLBACK';
            }
          });
        } else {
          // Fallback vers les valeurs par d√©faut
          logger.warn('‚ö†Ô∏è Impossible de r√©cup√©rer la config depuis Firebase, utilisation des valeurs par d√©faut');
          Object.keys(defaultConfig).forEach(key => {
            finalConfig[key] = defaultConfig[key];
            sources[key] = 'DEFAULT_FALLBACK';
          });
        }
      } catch (error) {
        logger.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration depuis Firebase, utilisation des valeurs par d√©faut:', error);
        Object.keys(defaultConfig).forEach(key => {
          finalConfig[key] = defaultConfig[key];
          sources[key] = 'DEFAULT_FALLBACK';
        });
      }
    }

    // Stocker les sources pour la tra√ßabilit√©
    this.configSources.firebase = sources;
    
    return finalConfig;
  }

    /**
   * Charge la configuration des sessions avec logique de priorit√© intelligente
   */
  async loadSessionConfig() {
    const env = this.environment;
    logger.info(`üîç Chargement de la configuration des sessions pour l'environnement: ${env}`);

    // Valeurs par d√©faut (fallback)
    const defaultSessionConfig = {
      userSessionDurationMonths: 6,
      pinSessionDurationConnectedDays: 7,
      pinSessionDurationAnonymousMinutes: 10
    };

    const finalConfig = {};
    const sources = {};

    // Priorit√© 1: Variables d'environnement VITE (pour le dev local)
    if (env === 'development') {
      logger.info('üîç Priorit√© 1: Recherche des configurations de session dans les variables VITE...');
      
      const viteConfig = this.loadSessionConfigFromViteEnv();
      Object.keys(defaultSessionConfig).forEach(key => {
        if (viteConfig[key] !== undefined) {
          finalConfig[key] = viteConfig[key];
          sources[key] = 'VITE_ENV';
        } else {
          finalConfig[key] = defaultSessionConfig[key];
          sources[key] = 'DEFAULT_FALLBACK';
        }
      });
    } else {
      // Priorit√© 2: Tentative de r√©cup√©ration depuis Firebase Functions
      logger.info('üîç Priorit√© 2: Tentative de r√©cup√©ration des configurations de session depuis Firebase Functions...');
      
      try {
        const firebaseConfig = await this.loadFromFirebaseFunctions();
        if (firebaseConfig && firebaseConfig.sessions) {
          logger.info('‚úÖ Configuration des sessions r√©cup√©r√©e depuis Firebase Functions');
          Object.keys(defaultSessionConfig).forEach(key => {
            if (firebaseConfig.sessions[key] !== undefined) {
              finalConfig[key] = firebaseConfig.sessions[key];
              sources[key] = 'FIREBASE_FUNCTIONS';
            } else {
              finalConfig[key] = defaultSessionConfig[key];
              sources[key] = 'DEFAULT_FALLBACK';
            }
          });
        } else {
          // Fallback vers les valeurs par d√©faut
          logger.warn('‚ö†Ô∏è Impossible de r√©cup√©rer la config des sessions depuis Firebase, utilisation des valeurs par d√©faut');
          Object.keys(defaultSessionConfig).forEach(key => {
            finalConfig[key] = defaultSessionConfig[key];
            sources[key] = 'DEFAULT_FALLBACK';
          });
        }
      } catch (error) {
        logger.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration des sessions depuis Firebase, utilisation des valeurs par d√©faut:', error);
        Object.keys(defaultSessionConfig).forEach(key => {
          finalConfig[key] = defaultSessionConfig[key];
          sources[key] = 'DEFAULT_FALLBACK';
        });
      }
    }

    // Stocker les sources pour la tra√ßabilit√©
    this.configSources.sessions = sources;

    return finalConfig;
  }

  /**
   * Charge les secrets Firebase avec logique de priorit√© intelligente
   */
  async loadSecretsConfig() {
    logger.info('üîê Chargement des secrets Firebase...');

    try {
      // Tentative de r√©cup√©ration depuis adminService
      const adminService = await import('./adminService.js');
      const secrets = await adminService.default.getSecrets();
      
      if (secrets && Object.keys(secrets).length > 0) {
        logger.info('‚úÖ Secrets Firebase r√©cup√©r√©s avec succ√®s');
        
        // Cr√©er les sources pour la tra√ßabilit√©
        const sources = {};
        Object.keys(secrets).forEach(key => {
          sources[key] = 'FIREBASE_SECRETS';
        });
        
        // Stocker les sources pour la tra√ßabilit√©
        this.configSources.secrets = sources;
        
        return secrets;
      } else {
        logger.warn('‚ö†Ô∏è Aucun secret Firebase trouv√©');
        this.configSources.secrets = {};
        return {};
      }
    } catch (error) {
      logger.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration des secrets Firebase:', error);
      this.configSources.secrets = {};
      return {};
    }
  }

  /**
   * Charge la configuration des sessions depuis les variables d'environnement VITE
   */
  loadSessionConfigFromViteEnv() {
    const config = {};
    
    // Mapping des variables VITE vers les cl√©s de session
    const viteMapping = {
      'VITE_USER_SESSION_DURATION_MONTHS': 'userSessionDurationMonths',
      'VITE_PIN_SESSION_DURATION_CONNECTED_DAYS': 'pinSessionDurationConnectedDays',
      'VITE_PIN_SESSION_DURATION_ANONYMOUS_MINUTES': 'pinSessionDurationAnonymousMinutes'
    };

    Object.entries(viteMapping).forEach(([viteKey, configKey]) => {
      const value = import.meta.env[viteKey];
      if (value !== undefined) {
        const parsedValue = parseInt(value);
        if (!isNaN(parsedValue)) {
          config[configKey] = parsedValue;
          logger.debug(`‚úÖ ${configKey} charg√© depuis ${viteKey}: ${parsedValue}`);
        } else {
          logger.warn(`‚ö†Ô∏è Valeur invalide pour ${viteKey}: ${value}`);
        }
      }
    });

    return config;
  }

  /**
   * Charge la configuration depuis les variables d'environnement VITE
   */
  loadFromViteEnv() {
    const config = {};
    
    // Mapping des variables VITE vers les cl√©s Firebase
    const viteMapping = {
      'VITE_FIREBASE_API_KEY': 'apiKey',
      'VITE_FIREBASE_AUTH_DOMAIN': 'authDomain',
      'VITE_FIREBASE_PROJECT_ID': 'projectId',
      'VITE_FIREBASE_STORAGE_BUCKET': 'storageBucket',
      'VITE_FIREBASE_MESSAGING_SENDER_ID': 'messagingSenderId',
      'VITE_FIREBASE_APP_ID': 'appId',
      'VITE_FIREBASE_MEASUREMENT_ID': 'measurementId'
    };

    Object.entries(viteMapping).forEach(([viteKey, configKey]) => {
      if (import.meta.env[viteKey]) {
        config[configKey] = import.meta.env[viteKey];
        logger.debug(`‚úÖ ${configKey} charg√© depuis ${viteKey}`);
      }
    });

    return config;
  }

  /**
   * Tente de r√©cup√©rer la configuration depuis Firebase Functions
   */
  async loadFromFirebaseFunctions() {
    try {
      // V√©rifier si on peut s'authentifier
      const authToken = await this.getAuthToken();
      if (!authToken) {
        logger.warn('‚ö†Ô∏è Pas de token d\'authentification, impossible de r√©cup√©rer la config Firebase');
        return null;
      }

      logger.info('üîê Tentative de r√©cup√©ration de la configuration depuis Firebase Functions...');
      
      const response = await fetch('https://us-central1-impro-selector.cloudfunctions.net/dumpEnvironment', {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        const result = await response.json();
        logger.info('‚úÖ Configuration r√©cup√©r√©e depuis Firebase Functions');
        return result.data || result;
      } else {
        logger.warn(`‚ö†Ô∏è Erreur HTTP ${response.status} lors de la r√©cup√©ration de la config Firebase`);
        return null;
      }
    } catch (error) {
      logger.error('‚ùå Erreur lors de la r√©cup√©ration depuis Firebase Functions:', error);
      return null;
    }
  }

  /**
   * Log de la tra√ßabilit√© des sources de configuration
   */
  logConfigSources() {
    logger.info('üîç Tra√ßabilit√© des sources de configuration:');
    
    if (this.configSources.firebase) {
      logger.info('  üî• Configuration Firebase:');
      Object.entries(this.configSources.firebase).forEach(([key, source]) => {
        logger.info(`    - ${key}: ${source}`);
      });
    }
    
    if (this.configSources.sessions) {
      logger.info('  ‚è∞ Configuration des sessions:');
      Object.entries(this.configSources.sessions).forEach(([key, source]) => {
        logger.info(`    - ${key}: ${source}`);
      });
    }
    
    if (this.configSources.secrets) {
      logger.info('  üîê Secrets Firebase:');
      Object.entries(this.configSources.secrets).forEach(([key, source]) => {
        logger.info(`    - ${key}: ${source}`);
      });
    }
  }

  /**
   * Retourne la source d'une valeur de configuration
   */
  getConfigSource(key, category = 'firebase') {
    return this.configSources[category]?.[key] || 'UNKNOWN';
  }

  /**
   * Retourne la base de donn√©es Firestore √† utiliser
   */
  getFirestoreDatabase() {
    return this.config.firestore.database;
  }

  /**
   * Retourne la r√©gion Firestore
   */
  getFirestoreRegion() {
    return this.config.firestore.region;
  }

  /**
   * Retourne la VAPID key pour les notifications push
   */
  getVapidKey() {
    return this.config.notifications.vapidKey;
  }

  /**
   * Retourne le bucket Storage √† utiliser
   */
  getStorageBucket() {
    return this.config.storage.bucket;
  }

  /**
   * Retourne le pr√©fixe Storage pour l'environnement
   */
  getStoragePrefix() {
    return this.config.storage.prefix;
  }

  /**
   * Retourne la configuration Firebase compl√®te
   */
  getFirebaseConfig() {
    return this.config.firebase;
  }

  /**
   * Retourne une cl√© Firebase sp√©cifique
   */
  getFirebaseKey(key) {
    return this.config.firebase[key];
  }

  /**
   * Retourne la cl√© API Firebase
   */
  getFirebaseApiKey() {
    return this.config.firebase.apiKey;
  }

  /**
   * Retourne le domaine d'authentification Firebase
   */
  getFirebaseAuthDomain() {
    return this.config.firebase.authDomain;
  }

  /**
   * Retourne l'ID du projet Firebase
   */
  getFirebaseProjectId() {
    return this.config.firebase.projectId;
  }

  /**
   * Retourne le bucket Storage Firebase
   */
  getFirebaseStorageBucket() {
    return this.config.firebase.storageBucket;
  }

  /**
   * Retourne l'ID de l'exp√©diteur Firebase
   */
  getFirebaseMessagingSenderId() {
    return this.config.firebase.messagingSenderId;
  }

  /**
   * Retourne l'ID de l'application Firebase
   */
  getFirebaseAppId() {
    return this.config.firebase.appId;
  }

  /**
   * Retourne l'ID de mesure Firebase
   */
  getFirebaseMeasurementId() {
    return this.config.firebase.measurementId;
  }

  /**
   * Retourne la dur√©e de session utilisateur en mois
   */
  getUserSessionDurationMonths() {
    return this.config.sessions?.userSessionDurationMonths || 6;
  }

  /**
   * Retourne la dur√©e de session PIN pour utilisateurs connect√©s en jours
   */
  getPinSessionDurationConnectedDays() {
    return this.config.sessions?.pinSessionDurationConnectedDays || 7;
  }

  /**
   * Retourne la dur√©e de session PIN pour utilisateurs anonymes en minutes
   */
  getPinSessionDurationAnonymousMinutes() {
    return this.config.sessions?.pinSessionDurationAnonymousMinutes || 10;
  }

  /**
   * Retourne les credentials Ethereal Email depuis les variables d'environnement
   * Priorit√©: .env.local > Firebase Secrets > Valeurs par d√©faut
   */
  getEtherealCredentials() {
    // Priorit√© 1: Variables d'environnement locales (.env.local)
    const localUser = import.meta.env.VITE_ETHEREAL_SMTP_USER;
    const localPass = import.meta.env.VITE_ETHEREAL_SMTP_PASS;
    
    if (localUser && localPass) {
      logger.info('üîê Credentials Ethereal r√©cup√©r√©s depuis .env.local');
      return {
        user: localUser,
        pass: localPass,
        source: 'local_env'
      };
    }
    
    // Priorit√© 2: Secrets Firebase (si disponibles)
    if (this.config?.secrets?.ethereal) {
      logger.info('üîê Credentials Ethereal r√©cup√©r√©s depuis Firebase Secrets');
      return {
        user: this.config.secrets.ethereal.smtp_user,
        pass: this.config.secrets.ethereal.smtp_pass,
        source: 'firebase_secrets'
      };
    }
    
    // Priorit√© 3: Valeurs par d√©faut (pour le d√©veloppement)
    logger.warn('‚ö†Ô∏è Aucun credential Ethereal configur√©, utilisation des valeurs par d√©faut');
    return {
      user: 'dev@ethereal.email',
      pass: 'dev_password',
      source: 'default'
    };
  }

  /**
   * V√©rifie si les credentials Ethereal sont configur√©s
   */
  isEtherealConfigured() {
    const credentials = this.getEtherealCredentials();
    return credentials.source !== 'default' && credentials.user && credentials.pass;
  }

  /**
   * Retourne la source des credentials Ethereal
   */
  getEtherealCredentialsSource() {
    const credentials = this.getEtherealCredentials();
    return credentials.source;
  }

  /**
   * Retourne la configuration email
   */
  getEmailConfig() {
    return this.config.email;
  }

  /**
   * Retourne la configuration d'exp√©diteur d'email
   */
  getEmailFromConfig() {
    const emailConfig = this.config.email;
    if (emailConfig?.from && emailConfig?.replyTo) {
      return {
        from: emailConfig.from.displayName,
        replyTo: emailConfig.replyTo
      };
    }
    return null;
  }

  /**
   * Retourne la dur√©e d'expiration des magic links en jours
   */
  getMagicLinkExpirationDays() {
    return this.config.magicLinks?.expirationDays || 7;
  }

  /**
   * Retourne les valeurs de fallback pour l'email
   */
  getEmailFallbackConfig() {
    return {
      from: 'HatCast <noreply@hatcast.com>',
      replyTo: 'noreply@hatcast.com'
    };
  }

  /**
   * Retourne l'URL de l'environnement
   */
  getHostingUrl() {
    return this.config.hosting.url;
  }

  /**
   * V√©rifie si on est en mode d√©veloppement
   */
  isDevelopment() {
    return this.environment === 'development';
  }

  /**
   * V√©rifie si on est en mode staging
   */
  isStaging() {
    return this.environment === 'staging';
  }

  /**
   * V√©rifie si on est en mode production
   */
  isProduction() {
    return this.environment === 'production';
  }

  /**
   * Retourne l'environnement actuel
   */
  getEnvironment() {
    if (!this.environment) {
      // Fallback si l'environnement n'est pas encore d√©tect√©
      this.environment = this.detectEnvironment();
    }
    return this.environment;
  }

  /**
   * Retourne la configuration compl√®te
   */
  getFullConfig() {
    return this.config;
  }

  /**
   * R√©cup√®re le token d'authentification Firebase
   */
  async getAuthToken() {
    try {
      const { getAuth } = await import('firebase/auth');
      const auth = getAuth();
      const user = auth.currentUser;
      
      if (user) {
        return await user.getIdToken();
      }
      return null;
    } catch (error) {
              logger.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration du token:', error);
      return null;
    }
  }

  /**
   * Dump toutes les variables d'environnement et la configuration
   * Utile pour le debug et la v√©rification des configs
   */
  async dumpEnvironmentInfo() {
    const envInfo = {
      // Informations de base
      currentUrl: window.location.href,
      hostname: window.location.hostname,
      environment: this.environment,
      
      // Configuration d√©tect√©e
      config: this.config,
      
      // Variables d'environnement disponibles (valeurs r√©elles pour admins)
      envVars: {
        NODE_ENV: import.meta.env.NODE_ENV || 'Non d√©fini',
        VITE_APP_TITLE: import.meta.env.VITE_APP_TITLE || 'Non d√©fini',
        VITE_FIREBASE_API_KEY: import.meta.env.VITE_FIREBASE_API_KEY || 'Non d√©fini',
        VITE_FIREBASE_AUTH_DOMAIN: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || 'Non d√©fini',
        VITE_FIREBASE_PROJECT_ID: import.meta.env.VITE_FIREBASE_PROJECT_ID || 'Non d√©fini',
        VITE_FIREBASE_STORAGE_BUCKET: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || 'Non d√©fini',
        VITE_FIREBASE_MESSAGING_SENDER_ID: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || 'Non d√©fini',
        VITE_FIREBASE_APP_ID: import.meta.env.VITE_FIREBASE_APP_ID || 'Non d√©fini',
        VITE_FIREBASE_MEASUREMENT_ID: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID || 'Non d√©fini',
        // Variables Vite natives
        DEV: import.meta.env.DEV,
        PROD: import.meta.env.PROD,
        BASE_URL: import.meta.env.BASE_URL || 'Non d√©fini',
        VITE_VERSION: import.meta.env.VITE_VERSION || 'Non d√©fini',
        // Variables syst√®me du navigateur
        'navigator.userAgent': navigator.userAgent,
        'navigator.platform': navigator.platform,
        'navigator.language': navigator.language,
        'window.location.href': window.location.href,
        'window.location.hostname': window.location.hostname,
        'window.location.port': window.location.port || 'Non d√©fini',
        'window.location.protocol': window.location.protocol,
        // Variables d'environnement syst√®me (si disponibles)
        'process.env.NODE_ENV': typeof process !== 'undefined' ? process.env?.NODE_ENV : 'Non disponible c√¥t√© client',
        'process.env.PLATFORM': typeof process !== 'undefined' ? process.env?.PLATFORM : 'Non disponible c√¥t√© client',
        'process.env.ARCH': typeof process !== 'undefined' ? process.env?.ARCH : 'Non disponible c√¥t√© client',
      },
      
      // Informations Firebase
      firebase: {
        projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || 'Non d√©fini',
        authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || 'Non d√©fini',
        storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || 'Non d√©fini',
      },
      
      // Informations de build
      build: {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
      }
    };

    // R√©cup√©rer les secrets Firebase si l'utilisateur est admin
    try {
      const adminService = await import('./adminService.js');
      const isAdmin = await adminService.default.checkAdminStatus();
      
      if (isAdmin) {
        logger.info('üîê Utilisateur admin d√©tect√©, r√©cup√©ration des secrets Firebase...');
        
        // R√©cup√©rer la configuration Firebase Functions
        const response = await fetch('https://us-central1-impro-selector.cloudfunctions.net/dumpEnvironment', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${await this.getAuthToken()}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          const firebaseConfig = await response.json();
          logger.info('üîê R√©ponse compl√®te Firebase:', firebaseConfig);
          envInfo.firebaseSecrets = firebaseConfig.data;
          logger.info('üîê Secrets Firebase r√©cup√©r√©s:', firebaseConfig.data);
          logger.info('üîê firebaseSecrets dans envInfo:', envInfo.firebaseSecrets);
        } else {
                      logger.warn('‚ö†Ô∏è Impossible de r√©cup√©rer les secrets Firebase:', response.status);
          envInfo.firebaseSecrets = { error: 'Acc√®s refus√© ou erreur serveur' };
        }
      } else {
        envInfo.firebaseSecrets = { message: 'Acc√®s r√©serv√© aux administrateurs' };
      }
    } catch (error) {
      logger.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration des secrets Firebase:', error);
      envInfo.firebaseSecrets = { error: error.message };
    }

    logger.info('üîç DEBUG - Informations d\'environnement HatCast:', envInfo);
    return envInfo;
  }

  /**
   * Retourne un r√©sum√© format√© pour l'affichage
   */
  async getEnvironmentSummary() {
    const info = await this.dumpEnvironmentInfo();
    
    return {
      environment: info.environment,
      url: info.currentUrl,
      // Configuration Firestore (d√©termin√©e c√¥t√© client)
      firestore: {
        database: info.config.firestore.database,
        region: info.config.firestore.region
      },
      // Configuration Storage (d√©termin√©e c√¥t√© client)
      storage: {
        bucket: info.config.storage.bucket,
        prefix: info.config.storage.prefix
      },
      // Configuration Email (d√©termin√©e c√¥t√© client)
      email: {
        service: info.config.email.service,
        capture: info.config.email.capture
      },
      // Configuration Notifications (d√©termin√©e c√¥t√© client)
      notifications: {
        vapidKey: info.config.notifications.vapidKey
      },
      // Configuration Firebase (variables d'environnement)
      firebase: {
        projectId: info.firebase.projectId,
        authDomain: info.firebase.authDomain
      },
      // Secrets Firebase (r√©cup√©r√©s c√¥t√© serveur)
      firebaseSecrets: info.firebaseSecrets
    };
  }
}

// Instance singleton
const configService = new ConfigService();

export default configService;
