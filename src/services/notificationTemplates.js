// src/services/notificationTemplates.js

/**
 * Centralized templates for multi-channel notifications.
 * Build per-channel payloads from a single input.
 */

import { buildAvailabilityEmailTemplate, buildSelectionEmailTemplate } from './emailTemplates.js'

export function buildNotificationPayloads({ reason, recipientName, eventTitle, eventDate, urls = {}, prefs = {}, extra = {} }) {
  const payloads = { email: null, push: null }

  if (reason === 'availability_request' || reason === 'availability_reminder') {
    const emailEnabled = prefs?.notifyAvailability !== false
    const pushEnabled = prefs?.notifyAvailabilityPush !== false

    payloads.email = {
      enabled: emailEnabled,
      subject: (reason === 'availability_reminder' ? `Rappel disponibilit√© ¬∑ ${eventTitle} (${eventDate})` : `Disponibilit√© demand√©e ¬∑ ${eventTitle} (${eventDate})`),
      // HTML est construit dans emailService.queueAvailabilityEmail pour garder l'impl√©mentation existante
    }
    payloads.push = {
      enabled: pushEnabled,
      title: reason === 'availability_reminder' ? '‚è∞ Rappel disponibilit√©' : `üéØ Nouvel √©v√©nement !`,
      body: reason === 'availability_reminder' ? `${recipientName}, ${eventTitle} (${eventDate})` : `üé≠ On a besoin de toi pour ${eventTitle} le ${eventDate} !`,
      data: { url: urls.eventUrl, yesUrl: urls.yesUrl, noUrl: urls.noUrl, reason }
    }
    
    // Log de d√©bogage pour les URLs
    console.log('URLs pour notifications de disponibilit√©:', {
      eventUrl: urls.eventUrl,
      yesUrl: urls.yesUrl,
      noUrl: urls.noUrl,
      urls
    })
  }

  if (reason === 'selection') {
    const emailEnabled = prefs?.notifySelection !== false
    const pushEnabled = prefs?.notifySelectionPush !== false

    // D√©terminer si c'est une √©quipe confirm√©e ou une s√©lection temporaire
    const isConfirmedTeam = extra.isConfirmedTeam || false

    payloads.email = {
      enabled: emailEnabled,
      subject: isConfirmedTeam ? `üéâ √âquipe confirm√©e pour ${eventTitle}` : `üé≠ Equipe pour ${eventTitle}`
      // HTML s√©lection g√©r√© dans emailService.queueAvailabilityEmail pour garder l'impl√©mentation existante
    }
    payloads.push = {
      enabled: pushEnabled,
      title: isConfirmedTeam ? `üéâ √âquipe confirm√©e !` : `üé≠ Confirme ta participation !`,
      body: isConfirmedTeam 
        ? extra.confirmedPlayers?.join(', ') || '√âquipe confirm√©e'
        : `üï∫ Pr√©pares-toi √† briller pour ${eventTitle} le ${eventDate}!`,
      data: { url: urls.eventUrl, noUrl: urls.noUrl, reason, isConfirmedTeam }
    }
    
    // Log de d√©bogage pour les URLs de s√©lection
    console.log('URLs pour notifications de s√©lection:', {
      eventUrl: urls.eventUrl,
      noUrl: urls.noUrl,
      urls
    })
  }

  // Nouveaux templates pour les rappels automatiques
  if (reason === 'reminder_7days' || reason === 'reminder_1day') {
    const emailEnabled = reason === 'reminder_7days' 
      ? prefs?.notifyReminder7Days !== false
      : prefs?.notifyReminder1Day !== false
    
    const pushEnabled = reason === 'reminder_7days'
      ? prefs?.notifyReminder7DaysPush !== false
      : prefs?.notifyReminder1DayPush !== false
    
    const is7Days = reason === 'reminder_7days'
    const daysText = is7Days ? '7 jours' : '1 jour'
    const emoji = is7Days ? 'üìÖ' : '‚è∞'

    payloads.email = {
      enabled: emailEnabled,
      subject: `${emoji} Rappel : ${eventTitle} dans ${daysText}`
    }
    
    payloads.push = {
      enabled: pushEnabled,
      title: `${emoji} Rappel √©v√©nement`,
      body: `${recipientName}, ${eventTitle} dans ${daysText} ! Es-tu pr√™t(e) ?`,
      data: { 
        url: urls.eventUrl, 
        noUrl: urls.noUrl, 
        reason,
        reminderType: reason,
        eventId: extra.eventId,
        seasonId: extra.seasonId
      }
    }
    
    console.log('URLs pour notifications de rappel:', {
      eventUrl: urls.eventUrl,
      noUrl: urls.noUrl,
      reason,
      reminderType: reason
    })
  }

  // Log de d√©bogage
  console.log('buildNotificationPayloads', { 
    reason, 
    recipientName, 
    prefs, 
    payloads,
    emailEnabled: payloads.email?.enabled,
    pushEnabled: payloads.push?.enabled
  })

  return payloads
}

/**
 * Templates de preview unifi√©s - utilis√©s √† la fois pour le preview ET l'envoi
 * √âlimine la duplication de code entre EventAnnounceModal.vue et l'envoi r√©el
 */

/**
 * Preview/Envoi push pour disponibilit√©
 */
export function buildAvailabilityPushPreview({ recipientName, eventTitle, eventDate }) {
  return {
    title: `üéØ Nouvel √©v√©nement !`,
    body: `üé≠ On a besoin de toi pour ${eventTitle} le ${eventDate} !`
  }
}

/**
 * Preview/Envoi push pour s√©lection
 */
export function buildSelectionPushPreview({ recipientName, eventTitle, eventDate }) {
  return {
    title: `üé≠ Confirme ta participation !`,
    body: `üï∫ Pr√©pares-toi √† briller pour ${eventTitle} le ${eventDate}!`
  }
}

/**
 * Preview/Envoi email pour disponibilit√©
 */
export function buildAvailabilityEmailPreview({ recipientName, eventTitle, eventDate, eventUrl, yesUrl, noUrl }) {
  return {
    subject: `üé≠ ${eventTitle} ¬∑ ${eventDate}`,
    from: 'HatCast',
    to: recipientName,
    html: buildAvailabilityEmailTemplate({ playerName: recipientName, eventTitle, eventDate, eventUrl, yesUrl, noUrl })
  }
}

/**
 * Preview/Envoi email pour s√©lection
 */
export function buildSelectionEmailPreview({ recipientName, eventTitle, eventDate, eventUrl, noUrl, confirmUrl }) {
  return {
    subject: `üé≠ Tu es dans la s√©lection pour ${eventTitle}!`,
    from: 'HatCast',
    to: recipientName,
    html: buildSelectionEmailTemplate({ playerName: recipientName, eventTitle, eventDate, eventUrl, noUrl, confirmUrl })
  }
}

/**
 * Message brut pour copier-coller dans la modale (texte simple)
 */
export function buildCopyMessage({ mode = 'event', eventTitle, eventDate, eventUrl, selectedPlayers = [] }) {
  if (mode === 'selection') {
    const playersList = (selectedPlayers || []).join(', ')
    return `S√©lection pour ${eventTitle} du ${eventDate} : ${playersList}`
  }
  return `Bonjour !\n\nNouvel √©v√©nement : ${eventTitle}\nDate : ${eventDate}\n\nLien direct vers l'√©v√©nement : ${eventUrl}\n\nMerci de confirmer votre disponibilit√©.`
}

/**
 * Texte de pr√©visualisation (personnalis√© par destinataire) align√© avec les notifications envoy√©es
 */
export function buildPreviewText({ mode = 'event', recipientName = '[Nom du joueur]', eventTitle, eventDate, eventUrl, selectedPlayers = [] }) {
  if (mode === 'selection') {
    const playersList = (selectedPlayers || []).join(', ')
    return `S√©lection confirm√©e\n\nBonjour ${recipientName},\n\nTu as √©t√© s√©lectionn√©(e) pour ${eventTitle} (${eventDate}).\n\nS√©lection compl√®te : ${playersList}.\n\nPlus d'infos : ${eventUrl}`
  }
  return `Disponibilit√© demand√©e\n\nBonjour ${recipientName},\n\nPeux-tu indiquer ta disponibilit√© pour ${eventTitle} (${eventDate}) ?\n\nLien de l'√©v√©nement : ${eventUrl}`
}


