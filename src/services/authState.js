import { ref, computed } from 'vue'
import { getFirebaseAuth } from './firebase.js'
import logger from './logger.js'
// Navigation tracking supprim√© - remplac√© par seasonPreferences

// √âtat global de l'authentification
const currentUser = ref(null)
const isInitialized = ref(false)
const isInitializing = ref(false)

// Computed properties
const isConnected = computed(() => {
  // Inclure les utilisateurs anonymes qui ont un email associ√©
  if (!currentUser.value) return false
  if (!currentUser.value.isAnonymous) return true
  // Pour les utilisateurs anonymes, v√©rifier s'ils ont un email dans localStorage
  return !!localStorage.getItem('userEmail')
})

const isAuthenticated = computed(() => {
  return !!currentUser.value
})

// Fonction pour forcer la synchronisation
function forceSync() {
  try {
    const auth = getFirebaseAuth()
    if (!auth) {
      logger.debug('Firebase Auth pas encore disponible pour la synchronisation')
      return
    }
    
    if (auth?.currentUser) {
      const user = auth.currentUser
      if (user !== currentUser.value) {
        currentUser.value = user
        logger.debug('Synchronisation forc√©e de l\'√©tat d\'authentification', { 
          user: currentUser.value?.email || 'non connect√©' 
        })
      }
    }
  } catch (error) {
    logger.error('Erreur lors de la synchronisation forc√©e', error)
  }
}

// Fonction pour initialiser le service
async function initialize() {
  if (isInitialized.value || isInitializing.value) {
    return
  }
  
  isInitializing.value = true
  
  try {
    // R√©cup√©rer l'instance Firebase Auth
    const auth = getFirebaseAuth()
    if (!auth) {
      throw new Error('Firebase Auth n\'est pas encore disponible')
    }
    
    // Initialiser l'√©tat imm√©diatement
    currentUser.value = auth.currentUser
    logger.debug('√âtat initial de l\'utilisateur:', currentUser.value?.email || 'non connect√©')
    
    // √âcouter les changements d'√©tat d'authentification
    const unsubscribe = auth.onAuthStateChanged(async (user) => {
      const previousUser = currentUser.value
      currentUser.value = user
      isInitialized.value = true
      isInitializing.value = false
      
      // Debug log for auth state changes
      logger.info('üîë AuthState: User changed', {
        hadUser: !!previousUser,
        hasUser: !!user,
        email: user?.email || 'none',
        photoURL: user?.photoURL || 'none',
        providers: user?.providerData?.map(p => p.providerId) || []
      })
      
      // Store user avatar for player avatars service
      if (user && user.email && user.photoURL) {
        try {
          const { storeUserAvatar, clearPlayerAvatarCache } = await import('./playerAvatars.js')
          storeUserAvatar(user.email, user.photoURL)
          
          // Vider le cache des avatars pour forcer le rechargement
          clearPlayerAvatarCache()
          
          logger.info('‚úÖ Avatar utilisateur sauvegard√© et cache vid√©', { email: user.email })
        } catch (error) {
          logger.debug('Could not store user avatar:', error)
        }
      }
      

      
      // Tracking de navigation et audit pour les changements d'authentification
      try {
        if (user && !previousUser) {
          // Nouvelle connexion - logger l'audit (navigation tracking supprim√©)
          
          // Logger la connexion
          const { default: AuditClient } = await import('./auditClient.js')
          await AuditClient.logLogin(user.email, 'firebase_auth')
          
        } else if (!user && previousUser) {
          // D√©connexion - effacer les sessions locales (navigation tracking supprim√©)
          
          // Logger la d√©connexion
          const { default: AuditClient } = await import('./auditClient.js')
          await AuditClient.logLogout(previousUser.email)
          
          // Effacer toutes les sessions locales (PIN et joueurs)
          try {
            const { default: pinSessionManager } = await import('./pinSession.js')
            const { default: playerPasswordSessionManager } = await import('./playerPasswordSession.js')
            
            pinSessionManager.clearSession()
            playerPasswordSessionManager.clearAllSessions()
            
            logger.info('Sessions locales effac√©es par le service centralis√©')
          } catch (sessionError) {
            logger.warn('Erreur lors de l\'effacement des sessions locales:', sessionError)
          }
        }
      } catch (error) {
        // Log silencieux pour les erreurs de tracking non critiques
        if (error.code !== 'permission-denied') {
          logger.error('Erreur lors du tracking de navigation:', error)
        }
      }
    })
    
    // Stocker la fonction de cleanup
    window._authStateUnsubscribe = unsubscribe
    
    logger.info('Service d\'√©tat d\'authentification initialis√© avec succ√®s')
  } catch (error) {
    logger.error('Erreur lors de l\'initialisation du service d\'authentification:', error)
    isInitializing.value = false
  }
}

// Fonction pour nettoyer
function cleanup() {
  if (window._authStateUnsubscribe) {
    window._authStateUnsubscribe()
    delete window._authStateUnsubscribe
  }
  isInitialized.value = false
  isInitializing.value = false
}

// Fonction pour attendre l'initialisation
function waitForInitialization() {
  return new Promise((resolve, reject) => {
    if (isInitialized.value) {
      resolve()
      return
    }
    
    // Si le service n'est pas en cours d'initialisation, attendre qu'il commence
    if (!isInitializing.value) {
      logger.info('Service d\'authentification pas encore initialis√©, attente du d√©marrage...')
      
      // Attendre que l'initialisation commence
      const checkStartInterval = setInterval(() => {
        if (isInitializing.value) {
          clearInterval(checkStartInterval)
          // Maintenant attendre que l'initialisation se termine
          const checkCompleteInterval = setInterval(() => {
            if (isInitialized.value) {
              clearInterval(checkCompleteInterval)
              resolve()
            }
          }, 100)
          
          // Timeout pour l'initialisation compl√®te
          setTimeout(() => {
            clearInterval(checkCompleteInterval)
            reject(new Error('Timeout d\'initialisation du service d\'authentification'))
          }, 10000)
        }
      }, 100)
      
      // Timeout pour le d√©marrage de l'initialisation
      setTimeout(() => {
        clearInterval(checkStartInterval)
        reject(new Error('Timeout d\'attente du d√©marrage du service d\'authentification'))
      }, 5000)
      return
    }
    
    const checkInterval = setInterval(() => {
      if (isInitialized.value) {
        clearInterval(checkInterval)
        resolve()
      }
    }, 100)
    
    // Timeout de s√©curit√©
    setTimeout(() => {
      clearInterval(checkInterval)
      logger.warn('Timeout de waitForInitialization, rejet de la promesse')
      reject(new Error('Timeout d\'initialisation du service d\'authentification'))
    }, 5000)
  })
}

// Fonction pour forcer l'initialisation
function forceInitialize() {
  if (!isInitialized.value && !isInitializing.value) {
    autoInitialize()
  }
}

// Initialiser automatiquement avec un d√©lai pour laisser Firebase se charger
let retryCount = 0
const maxRetries = 20 // Augmenter le nombre de tentatives
const baseDelay = 500 // 500ms de base

function autoInitialize() {
  // V√©rifier si Firebase est disponible ET compl√®tement initialis√©
  const auth = getFirebaseAuth()
  if (!auth || !window.firebaseInitialized) {
    if (retryCount < maxRetries) {
      // Calculer le d√©lai avec backoff exponentiel (max 10 secondes)
      const delay = Math.min(baseDelay * Math.pow(2, retryCount), 10000)
      retryCount++
      
      logger.warn(`Firebase auth non disponible ou non initialis√©, tentative ${retryCount}/${maxRetries} dans ${delay}ms`)
      setTimeout(autoInitialize, delay)
      return
    } else {
      logger.error('Nombre maximum de tentatives atteint, arr√™t de l\'auto-initialisation')
      isInitializing.value = false
      return
    }
  }
  
  // Reset du compteur de tentatives
  retryCount = 0
  
  try {
    initialize()
  } catch (error) {
    logger.error('Erreur lors de l\'auto-initialisation:', error)
    // R√©essayer avec backoff exponentiel
    if (retryCount < maxRetries) {
      const delay = Math.min(baseDelay * Math.pow(2, retryCount), 10000)
      retryCount++
      logger.warn(`Erreur d'initialisation, tentative ${retryCount}/${maxRetries} dans ${delay}ms`)
      setTimeout(autoInitialize, delay)
    } else {
      logger.error('Nombre maximum de tentatives atteint, arr√™t de l\'auto-initialisation')
      isInitializing.value = false
    }
  }
}

// D√©marrer l'auto-initialisation
setTimeout(autoInitialize, 100)

// Cache pour les r√¥les Super Admin
const superAdminCache = ref(null)
const superAdminCacheTimestamp = ref(null)
const CACHE_VALIDITY = 5 * 60 * 1000 // 5 minutes

/**
 * V√©rifie si l'utilisateur actuel est Super Admin
 * Utilise les Cloud Functions avec fallback gracieux
 */
async function isSuperAdmin(force = false) {
  try {
    const auth = getFirebaseAuth()
    const user = auth?.currentUser
    
    if (!user?.email) {
      return false
    }
    
    const now = Date.now()
    
    // V√©rifier le cache si pas de force refresh
    if (!force && superAdminCache.value !== null && superAdminCacheTimestamp.value) {
      if (now - superAdminCacheTimestamp.value < CACHE_VALIDITY) {
        logger.debug('üîê Statut Super Admin r√©cup√©r√© du cache')
        return superAdminCache.value
      }
    }
    
    logger.info('üîê V√©rification du statut Super Admin via Cloud Functions...')
    
    // Appeler la Cloud Function pour v√©rifier le statut Super Admin
    const token = await user.getIdToken()
    const response = await fetch('https://us-central1-impro-selector.cloudfunctions.net/checkSuperAdminStatus', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    })
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${await response.text()}`)
    }
    
    const result = await response.json()
    const isAdmin = result.isSuperAdmin || false
    
    // Mettre en cache
    superAdminCache.value = isAdmin
    superAdminCacheTimestamp.value = now
    
    logger.info(`üîê Statut Super Admin: ${isAdmin ? '‚úÖ OUI' : '‚ùå NON'}`)
    return isAdmin
    
  } catch (error) {
    logger.error('‚ùå Erreur lors de la v√©rification Super Admin:', error)
    
    // Fallback gracieux vers impropick@gmail.com en cas d'erreur
    const auth = getFirebaseAuth()
    const user = auth?.currentUser
    const isFallback = user?.email === 'impropick@gmail.com'
    
    if (isFallback) {
      logger.warn('üîê Utilisation du fallback de d√©veloppement (impropick@gmail.com)')
      superAdminCache.value = true
      superAdminCacheTimestamp.value = Date.now()
      return true
    }
    
    // Pour tous les autres utilisateurs, retourner false en cas d'erreur
    superAdminCache.value = false
    superAdminCacheTimestamp.value = Date.now()
    return false
  }
}

/**
 * Vide le cache des r√¥les Super Admin
 */
function clearSuperAdminCache() {
  superAdminCache.value = null
  superAdminCacheTimestamp.value = null
  logger.debug('üîê Cache Super Admin vid√©')
}

export {
  currentUser,
  isConnected,
  isAuthenticated,
  isInitialized,
  isInitializing,
  forceSync,
  initialize,
  cleanup,
  waitForInitialization,
  forceInitialize,
  isSuperAdmin,
  clearSuperAdminCache
}
